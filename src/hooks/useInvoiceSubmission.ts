
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useFileUpload } from './useFileUpload';
import { addDays, format as formatDate } from 'date-fns';

interface SubmitInvoiceData {
  externalInvoiceNumber?: string;
  totalAmount: number;
  workOrders: Array<{
    workOrderId: string;
    amount: number;
    description?: string;
  }>;
  attachments?: File[];
  organizationId?: string; // For admin submissions
  createdByAdminId?: string; // Track admin who submitted
  adminNotes?: string; // Notes for admin-entered invoices

  // New fields
  invoiceDate?: Date | string;
  dueDate?: Date | string;
  subcontractorNotes?: string;
  paymentTerms?: string; // Defaults to Net 30
  purchaseOrderNumber?: string;
}

const toDateOnlyString = (value?: Date | string) => {
  if (!value) return undefined;
  if (typeof value === 'string') return value.slice(0, 10);
  return formatDate(value, 'yyyy-MM-dd');
};

export const useInvoiceSubmission = () => {
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const { uploadFiles } = useFileUpload({ context: 'invoice' });

  const submitInvoice = useMutation({
    mutationFn: async (data: SubmitInvoiceData) => {
      // Get current auth user and their profile
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('No authenticated user');

      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('id')
        .eq('user_id', user.id)
        .maybeSingle();

      if (profileError || !profile?.id) throw new Error('User profile not found');

      let organizationId = data.organizationId;
      
      // If no organization specified (normal subcontractor flow), get user's organization
      if (!organizationId) {
        const { data: userOrg, error: userOrgError } = await supabase
          .from('organization_members')
          .select('organization_id')
          .eq('user_id', profile.id)
          .limit(1)
          .maybeSingle();

        if (userOrgError || !userOrg?.organization_id) throw new Error('User organization not found');
        organizationId = userOrg.organization_id;
      }

      // Prepare dates with defaults
      const invoiceDateStr = toDateOnlyString(data.invoiceDate) ?? toDateOnlyString(new Date());
      const dueDateStr = toDateOnlyString(data.dueDate) 
        ?? toDateOnlyString(addDays(invoiceDateStr ? new Date(invoiceDateStr) : new Date(), 30));

      // Create the invoice record (internal_invoice_number is auto-generated)
      const { data: invoice, error: invoiceError } = await supabase
        .from('invoices')
        .insert({
          external_invoice_number: data.externalInvoiceNumber || null,
          total_amount: data.totalAmount,
          submitted_at: new Date().toISOString(),
          status: 'submitted' as const,
          subcontractor_organization_id: organizationId,
          submitted_by: profile.id,
          created_by_admin_id: data.createdByAdminId || null,
          admin_notes: data.adminNotes || null,
          subcontractor_notes: data.subcontractorNotes || null,
          payment_terms: data.paymentTerms || 'Net 30',
          purchase_order_number: data.purchaseOrderNumber || null,
          invoice_date: invoiceDateStr,
          due_date: dueDateStr,
          internal_invoice_number: '' // Will be auto-generated by trigger
        })
        .select('id, internal_invoice_number')
        .single();

      if (invoiceError) throw invoiceError;

      // Create invoice work order relationships
      const workOrderInserts = data.workOrders.map(wo => ({
        invoice_id: invoice.id,
        work_order_id: wo.workOrderId,
        amount: wo.amount,
        description: wo.description || null
      }));

      const { error: workOrderError } = await supabase
        .from('invoice_work_orders')
        .insert(workOrderInserts);

      if (workOrderError) throw workOrderError;

      // Upload attachments if provided
      if (data.attachments && data.attachments.length > 0) {
        const chosenWorkOrderId = data.workOrders[0]?.workOrderId;
        if (!chosenWorkOrderId) {
          console.warn('No work order selected for attachments; skipping upload.');
        } else {
          if (data.workOrders.length > 1) {
            toast({
              title: 'Heads up',
              description: 'Multiple work orders detected. Attachments will be linked to the first work order for now.',
            });
          }

          try {
            await uploadFiles(data.attachments, false, chosenWorkOrderId, undefined, invoice.id);
          } catch (uploadError) {
            console.warn('Failed to upload attachments:', uploadError);
          }
        }
      }

      return invoice;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['invoices'] });
      toast({
        title: 'Invoice Submitted',
        description: `Invoice ${data.internal_invoice_number} has been submitted and admins have been notified.`,
      });
    },
    onError: (error) => {
      console.error('Error submitting invoice:', error);
      toast({
        title: 'Error',
        description: 'Failed to submit invoice. Please try again.',
        variant: 'destructive',
      });
    },
  });

  return {
    submitInvoice: submitInvoice.mutate,
    submitInvoiceAsync: submitInvoice.mutateAsync,
    isSubmitting: submitInvoice.isPending,
  };
};

