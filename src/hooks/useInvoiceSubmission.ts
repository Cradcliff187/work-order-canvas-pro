import { useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useFileUpload } from './useFileUpload';

interface SubmitInvoiceData {
  externalInvoiceNumber?: string;
  totalAmount: number;
  workOrders: Array<{
    workOrderId: string;
    amount: number;
    description?: string;
  }>;
  attachments?: File[];
  organizationId?: string; // For admin submissions
  createdByAdminId?: string; // Track admin who submitted
  adminNotes?: string; // Notes for admin-entered invoices
}

export const useInvoiceSubmission = () => {
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const { uploadFiles } = useFileUpload({ context: 'invoice' });

  const submitInvoice = useMutation({
    mutationFn: async (data: SubmitInvoiceData) => {
      // Get current auth user and their profile
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('No authenticated user');

      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('id')
        .eq('user_id', user.id)
        .maybeSingle();

      if (profileError || !profile?.id) throw new Error('User profile not found');

      let organizationId = data.organizationId;
      
      // If no organization specified (normal subcontractor flow), get user's organization
      if (!organizationId) {
        const { data: userOrg, error: userOrgError } = await supabase
          .from('organization_members')
          .select('organization_id')
          .eq('user_id', profile.id)
          .limit(1)
          .maybeSingle();

        if (userOrgError || !userOrg?.organization_id) throw new Error('User organization not found');
        organizationId = userOrg.organization_id;
      }

      // Create the invoice record (internal_invoice_number is auto-generated)
      const { data: invoice, error: invoiceError } = await supabase
        .from('invoices')
        .insert({
          external_invoice_number: data.externalInvoiceNumber || null,
          total_amount: data.totalAmount,
          submitted_at: new Date().toISOString(),
          status: 'submitted' as const,
          subcontractor_organization_id: organizationId,
          submitted_by: profile.id,
          created_by_admin_id: data.createdByAdminId || null,
          admin_notes: data.adminNotes || null,
          internal_invoice_number: '' // Will be auto-generated by trigger
        })
        .select('id, internal_invoice_number')
        .single();

      if (invoiceError) throw invoiceError;

      // Create invoice work order relationships
      const workOrderInserts = data.workOrders.map(wo => ({
        invoice_id: invoice.id,
        work_order_id: wo.workOrderId,
        amount: wo.amount,
        description: wo.description || null
      }));

      const { error: workOrderError } = await supabase
        .from('invoice_work_orders')
        .insert(workOrderInserts);

      if (workOrderError) throw workOrderError;

      // Upload attachments if provided
      if (data.attachments && data.attachments.length > 0) {
        try {
          await uploadFiles(data.attachments);
        } catch (uploadError) {
          console.warn('Failed to upload attachments:', uploadError);
          // Don't fail the entire operation for attachment issues
          // The invoice is already created and submitted
        }
      }


      return invoice;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['invoices'] });
      toast({
        title: 'Invoice Submitted',
        description: `Invoice ${data.internal_invoice_number} has been submitted and admins have been notified.`,
      });
    },
    onError: (error) => {
      console.error('Error submitting invoice:', error);
      toast({
        title: 'Error',
        description: 'Failed to submit invoice. Please try again.',
        variant: 'destructive',
      });
    },
  });

  return {
    submitInvoice: submitInvoice.mutate,
    submitInvoiceAsync: submitInvoice.mutateAsync,
    isSubmitting: submitInvoice.isPending,
  };
};