
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useFileUpload } from './useFileUpload';
import { addDays, format as formatDate } from 'date-fns';

interface SubmitInvoiceData {
  externalInvoiceNumber?: string;
  totalAmount: number;
  workOrders: Array<{
    workOrderId: string;
    amount: number;
    description?: string;
  }>;
  attachments?: File[];
  organizationId?: string; // For admin submissions
  createdByAdminId?: string; // Track admin who submitted
  adminNotes?: string; // Notes for admin-entered invoices

  // New fields
  invoiceDate?: Date | string;
  dueDate?: Date | string;
  subcontractorNotes?: string;
  paymentTerms?: string; // Defaults to Net 30
  purchaseOrderNumber?: string;
}

const toDateOnlyString = (value?: Date | string) => {
  if (!value) return undefined;
  if (typeof value === 'string') return value.slice(0, 10);
  return formatDate(value, 'yyyy-MM-dd');
};

export const useInvoiceSubmission = () => {
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const { uploadFiles } = useFileUpload({ context: 'invoice' });

  const submitInvoice = useMutation({
    mutationFn: async (data: SubmitInvoiceData) => {
      // Get current auth user and their profile
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('No authenticated user');

      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('id')
        .eq('user_id', user.id)
        .maybeSingle();

      if (profileError || !profile?.id) throw new Error('User profile not found');

      let organizationId = data.organizationId;
      
      // If no organization specified (normal subcontractor flow), get user's organization
      if (!organizationId) {
        const { data: userOrg, error: userOrgError } = await supabase
          .from('organization_members')
          .select('organization_id')
          .eq('user_id', profile.id)
          .limit(1)
          .maybeSingle();

        if (userOrgError || !userOrg?.organization_id) throw new Error('User organization not found');
        organizationId = userOrg.organization_id;
      }

      // Prepare dates with defaults
      const invoiceDateStr = toDateOnlyString(data.invoiceDate) ?? toDateOnlyString(new Date());
      const dueDateStr = toDateOnlyString(data.dueDate) 
        ?? toDateOnlyString(addDays(invoiceDateStr ? new Date(invoiceDateStr) : new Date(), 30));

      // Create the invoice record (internal_invoice_number is auto-generated)
      const { data: invoice, error: invoiceError } = await supabase
        .from('invoices')
        .insert({
          external_invoice_number: data.externalInvoiceNumber || null,
          total_amount: data.totalAmount,
          submitted_at: new Date().toISOString(),
          status: 'submitted' as const,
          subcontractor_organization_id: organizationId,
          submitted_by: profile.id,
          created_by_admin_id: data.createdByAdminId || null,
          admin_notes: data.adminNotes || null,
          subcontractor_notes: data.subcontractorNotes || null,
          payment_terms: data.paymentTerms || 'Net 30',
          purchase_order_number: data.purchaseOrderNumber || null,
          invoice_date: invoiceDateStr,
          due_date: dueDateStr,
          internal_invoice_number: '' // Will be auto-generated by trigger
        })
        .select('id, internal_invoice_number')
        .single();

      if (invoiceError) throw invoiceError;

      // Query for approved work order reports to link to invoice_work_orders
      const workOrderIds = data.workOrders.map(wo => wo.workOrderId);
      const { data: approvedReports, error: reportsError } = await supabase
        .from('work_order_reports')
        .select('id, work_order_id, submitted_at')
        .in('work_order_id', workOrderIds)
        .eq('status', 'approved')
        .order('submitted_at', { ascending: false });

      if (reportsError) throw reportsError;

      // Create mapping of work_order_id to most recent approved report_id
      const reportMap = new Map<string, string>();
      const processedWorkOrders = new Set<string>();
      
      approvedReports?.forEach(report => {
        if (!processedWorkOrders.has(report.work_order_id)) {
          reportMap.set(report.work_order_id, report.id);
          processedWorkOrders.add(report.work_order_id);
        }
      });

      // Count work orders without approved reports for user feedback
      const workOrdersWithoutReports = workOrderIds.filter(id => !reportMap.has(id));
      
      if (workOrdersWithoutReports.length > 0) {
        console.warn('Work orders without approved reports:', workOrdersWithoutReports);
        toast({
          title: 'Warning: Missing Reports',
          description: `${workOrdersWithoutReports.length} work order(s) don't have approved reports. They may not appear in partner billing until reports are approved.`,
          variant: 'default',
        });
      }

      // Create invoice work order relationships with work_order_report_id
      const workOrderInserts = data.workOrders.map(wo => ({
        invoice_id: invoice.id,
        work_order_id: wo.workOrderId,
        work_order_report_id: reportMap.get(wo.workOrderId) || null,
        amount: wo.amount,
        description: wo.description || null
      }));

      const { error: workOrderError } = await supabase
        .from('invoice_work_orders')
        .insert(workOrderInserts);

      if (workOrderError) throw workOrderError;

      // Upload attachments if provided
      if (data.attachments && data.attachments.length > 0) {
        const chosenWorkOrderId = data.workOrders[0]?.workOrderId;
        if (!chosenWorkOrderId) {
          console.warn('No work order selected for attachments; skipping upload.');
        } else {
          if (data.workOrders.length > 1) {
            toast({
              title: 'Heads up',
              description: 'Multiple work orders detected. Attachments will be linked to the first work order for now.',
            });
          }

          try {
            await uploadFiles(data.attachments, false, chosenWorkOrderId, undefined, invoice.id);
          } catch (uploadError) {
            console.warn('Failed to upload attachments:', uploadError);
          }
        }
      }

      return invoice;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['invoices'] });
      toast({
        title: 'Invoice Submitted',
        description: `Invoice ${data.internal_invoice_number} has been submitted and admins have been notified.`,
      });
    },
    onError: (error) => {
      console.error('Error submitting invoice:', error);
      toast({
        title: 'Error',
        description: 'Failed to submit invoice. Please try again.',
        variant: 'destructive',
      });
    },
  });

  return {
    submitInvoice: submitInvoice.mutate,
    submitInvoiceAsync: submitInvoice.mutateAsync,
    isSubmitting: submitInvoice.isPending,
  };
};

